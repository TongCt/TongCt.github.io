<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++的参数传递方式]]></title>
    <url>%2F2019%2F04%2F16%2Fc-%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[c++的参数传递方式有三种分别是1.按值传递2.按引用传递3.指针传递今天在写代码的时候，发现在main函数中定义了一个栈与对队列，当把栈与队列通过Inverse函数之后发现原本的栈与队列并没有变化，经过debug发现这是因为在写c++函数的时候，要注意参数的传递。 ##按值传递1234567891011121314151617181920212223242526272829303132333435363738394041424344// test1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;void test_empty(stack&lt;int&gt;mystack, queue&lt;int&gt;myqueue)&#123; for (int i = 0; i &lt; 10; i++) &#123; myqueue.push(i); //cout &lt;&lt; myqueue.front() &lt;&lt; endl; &#125;&#125;void Inverse(stack&lt;int&gt; S, queue&lt;int&gt; Q) &#123; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); S.push(x); &#125; while (!S.empty()) &#123; int temp = S.top(); // cout &lt;&lt; temp &lt;&lt; endl; Q.push(temp); int fro = Q.front(); S.pop(); &#125;&#125;int main()&#123; stack&lt;int&gt;mystack; queue&lt;int&gt;myqueue; test_empty(mystack,myqueue); Inverse(mystack, myqueue); while (!myqueue.empty()) &#123; cout &lt;&lt; myqueue.front() &lt;&lt; endl; int j = myqueue.front(); myqueue.pop(); &#125; return 0;&#125; 运行这样的代码会发现这里的mystack与myqueue并没有被附上值，也没有被inverse形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-&gt;形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 ##按引用传参1234567891011121314151617181920212223242526272829303132333435363738394041424344// test1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include&lt;stack&gt;#include&lt;queue&gt;using namespace std;void test_empty(stack&lt;int&gt;&amp;mystack, queue&lt;int&gt;&amp;myqueue)&#123; for (int i = 0; i &lt; 10; i++) &#123; myqueue.push(i); //cout &lt;&lt; myqueue.front() &lt;&lt; endl; &#125;&#125;void Inverse(stack&lt;int&gt; &amp;S, queue&lt;int&gt;&amp; Q) &#123; while (!Q.empty()) &#123; int x = Q.front(); Q.pop(); S.push(x); &#125; while (!S.empty()) &#123; int temp = S.top(); // cout &lt;&lt; temp &lt;&lt; endl; Q.push(temp); int fro = Q.front(); S.pop(); &#125;&#125;int main()&#123; stack&lt;int&gt;mystack; queue&lt;int&gt;myqueue; test_empty(mystack,myqueue); Inverse(mystack, myqueue); while (!myqueue.empty()) &#123; cout &lt;&lt; myqueue.front() &lt;&lt; endl; int j = myqueue.front(); myqueue.pop(); &#125; return 0;&#125; 这样改代码之后，代码就能正确的逆序输出queue里的值了，这是按引用传参，虽然在main函数中传入的参数名依然是mystack与myqueue但是，在函数执行的时候是在&amp;mystack中执行的，改变的依然是函数的地址。形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈 中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过 栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 ##按指针传值1234567891011121314151617181920212223242526272829#include&lt;iostream&gt; 2 using namespace std; 3 //值传递 4 void change1(int n)&#123; 5 cout&lt;&lt;&quot;值传递--函数操作地址&quot;&lt;&lt;&amp;n&lt;&lt;endl; //显示的是拷贝的地址而不是源地址 6 n++; 7 &#125; 8 9 //引用传递10 void change2(int &amp; n)&#123;11 cout&lt;&lt;&quot;引用传递--函数操作地址&quot;&lt;&lt;&amp;n&lt;&lt;endl; 12 n++;13 &#125;14 //指针传递15 void change3(int *n)&#123;16 cout&lt;&lt;&quot;指针传递--函数操作地址 &quot;&lt;&lt;n&lt;&lt;endl; 17 *n=*n+1;18 &#125; 19 int main()&#123;20 int n=10;21 cout&lt;&lt;&quot;实参的地址&quot;&lt;&lt;&amp;n&lt;&lt;endl;22 change1(n);23 cout&lt;&lt;&quot;after change1() n=&quot;&lt;&lt;n&lt;&lt;endl;24 change2(n);25 cout&lt;&lt;&quot;after change2() n=&quot;&lt;&lt;n&lt;&lt;endl;26 change3(&amp;n);27 cout&lt;&lt;&quot;after change3() n=&quot;&lt;&lt;n&lt;&lt;endl;28 return true;29 &#125; 从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。 而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。 在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的： 指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变） 而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。 引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。https://xinklabi.iteye.com/blog/653643]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转链表]]></title>
    <url>%2F2019%2F03%2F30%2F%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[这道题使用的是单链表连成一个循环链表，然后移步更换头节点：1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; ListNode* p = head; int len=1; if(head==NULL || head-&gt;next==NULL)&#123; return head; &#125; while(p-&gt;next!=NULL)&#123; len=len+1; p=p-&gt;next; &#125; if(k%len==0)&#123; return head; &#125; p-&gt;next=head; int move=len-k%len; while(move--)&#123; p=p-&gt;next; &#125; head=p-&gt;next; p-&gt;next=NULL; return head; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode 链表 c++ 算法</category>
      </categories>
      <tags>
        <tag>链表 leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两两交换链表中的节点]]></title>
    <url>%2F2019%2F03%2F29%2F%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 我们把这个题拆成小问题，每两个相邻的指针进行交换容易实现，关键是怎么把每个交换好的小部分连接起来，我们用到了一个辅助指针用来指向上一个小块的末尾指针，让上一个换好位置的小块与下一个换好位置的指针相连接。12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head==NULL||head-&gt;next==NULL)&#123; return head; &#125; ListNode *p=head, *q = head-&gt;next,*r=head; while(1)&#123; p-&gt;next=q-&gt;next; q-&gt;next=p; if(p==head)&#123; head=q; &#125; p=p-&gt;next; if(p==NULL || p-&gt;next==NULL) break; q=p-&gt;next; r-&gt;next=q; //这里的r指针表示的是上一个交换组合的后一个元素，这样就可以把下一个交换元素组合连接在一起了 r=p; &#125; return head; &#125;&#125;;]]></content>
      <categories>
        <category>leetcode 链表 c++ 算法</category>
      </categories>
      <tags>
        <tag>leetcode 链表 c++ 算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下安装ss科学上网]]></title>
    <url>%2F2019%2F03%2F27%2Fubuntu%E4%B8%8B%E5%AE%89%E8%A3%85ss%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[##ubuntu下安装shadowsocks ubuntu系统是18.4，如果是16.04的版本不支持chacha20-ietf-poly1305加密，在17.04及以上的版本可以直接安装shadowsocks-libev. ##安装shadowsocks12sudo apt install python-pipsudo apt install shadowsocks-libev ##设置配置文件1sudo gedit /etc/shadowsocks-libev/config.json 然后编辑服务器的地址，密码之类。这一步之后就可以在终端用命令行打开ss了1ss-local -c /etc/shadowsocks-libev/config.json 运行效果如下： ##配置chrome代理完成上面的步骤还不能访问google，还需要设置代理服务，下载chromium1sudo apt-get install chromium-browser 然后到github上下载SwitchyOmega.crx文件在chrome里输入chrome://extensions/然后把那.crx文件后缀改成.zip拖入到chrome的扩展里进行安装。完成以后在情景模式中选择proxy,在代理服务器中的代理协议选择 socks5，本地代理服务器 127.0.0.1，代理窗口1080。完成之后，一定一定要点击下面的应用选项，进行保存！！最后一部是选择proxy，这样扩展程序的圈就从黑色变成了蓝色，就可以顺利的访问google了]]></content>
      <categories>
        <category>编程 ubuntu shadowsocks</category>
      </categories>
      <tags>
        <tag>ubuntu shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F22%2Fhello%2F</url>
    <content type="text"><![CDATA[title: hello worlddate: 2019-01-26 16:06:42 tags: “test”hello world Test the blog.]]></content>
  </entry>
  <entry>
    <title><![CDATA[java map的用法]]></title>
    <url>%2F2019%2F02%2F11%2Fjava%20set%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[今天做了一个leetcode上的题：求无重复最小字符串。这道题有一个思路就是构建一个滑动的窗口，例如[i,j]是一个窗口，在字符串上滑动，先让j++如果s[j]不在在我们建立的set里，就把它加加进去，同时j往下滑，如果j在这个窗口里，说明有重复的字符串，我们让i往下滑，记录最长的字符串大小。这道算法题用到了java里的set概念。所以这里就介绍一下set的具体的用法：set几何中没有重复的元素，map中包含的是键值跟对应的元素。用法：set&lt;&gt;set = new Hashset&lt;&gt;();判定是否有重复元素的时候调用set.contain()函数，此外还有set.add()进行操作。把代码附上：1234567891011121314151617181920212223242526272829303132class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int ans=0; int i,j=0; if(s.length()==1)&#123; ans=1; &#125;else&#123; for(i=0;i&lt;s.length()-1;i++)&#123; Set&lt;Character&gt; set = new HashSet&lt;&gt;(); set.add(s.charAt(i)); int max_size=1; if(ans&lt;max_size)&#123; ans=max_size; &#125; for(j=i+1;j&lt;s.length();j++)&#123; if(!set.contains(s.charAt(j)))&#123; set.add(s.charAt(j)); max_size++; if(ans&lt;max_size)&#123; ans=max_size; &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>java 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小情书]]></title>
    <url>%2F2019%2F01%2F30%2F%E5%B0%8F%E6%83%85%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[外面的雨下的很大，一直都很大的下着。其实我不想回复你的微信，这样说你可能会假装生气，然后不停的唠叨，想看我词穷不知道怎么哄你的样子。虽然我知道你的套路，可总是吃这一套。 今天一大早我的心情不好，你也是知道的。你以为我是因为考研调剂的事情而不开心，可是，人，要是不开心，那会有这么简单的理由啊。我们每天都是这么碌碌无为，沉沉闷闷的活着，至今日不知昨日，明日又如今日。这种的生活哪有什么大悲大喜可以发泄，那些小悲小喜，也就如同一滩死水上流过的风，泛起一点点的波痕，转瞬又了无痕迹。这样的日子，我过了很多年。我厌倦了。 给你说一个很好玩的事，上周日我去做大保健，你知道我想的是什么吗？你肯定想不到，毕竟51分钟前你刚骂我猥琐。其实我想的是宇宙的起源啊，你想想啊，这么大的一个宇宙，都是有一个一个的粒子组成的呀，这些粒子在微观上遵守的是量子力学的准则，怎么就在宇宙尺度上跟量子力学相悖了呢。举个例子，数字的加减乘除我们都会，实数就是数学界的基本粒子，这些基本粒子间又不同的运算的规则，这些规则就是积分啊，矩阵运算啊，保罗万象。像不像那些基本粒子，他们通过不同的力或者场的相互作用，形成了各种原子，分子，太阳，宇宙，和你我。我们本身的存在就是一种组合方式。按理说，宇宙之大，存在的都是一条条公式，一种种组合。只是有一些组合的规则过于复杂，我们弄不清楚罢了。但是，我想知道，宇宙中的本质是什么。声波因为是因为机械振动产生的，光播是能量的激发，这世界上的一切事物，都是能量赋予到了物质上，然后千变万化，可是，能量是什么，是什么在推动这个宇宙的运转，它的原始的能量，来自何方。 人类真的是唯一会思考宇宙的东西吗？为什么人类有强烈的了解宇宙的渴望，因为人类是依靠宇宙规律维持统治的生物吗？人类和别的动物的本质差别在哪里？有人说善良，羞耻心的什么的，这些人真是自大又无知。按照我们思索宇宙的方式来思索人类社会。人类最本质的东西是什么，我想那就是因为人类会协作。人类的这一种协作不同于蚂蚁之类的群居动物，人类会创造概念，会创造一些虚拟又很让人信服的东西，比如说善良，羞耻心。我们生活在无数的祖先创造的虚幻的概念之中。只有相信共同叙事的人类，才有可能协作在一起。蚂蚁，蜜蜂也会有信号的交流，但是它们编不出来故事，他们不会设计出复杂的工具，系统，然后让别的同类也能接受。人类所有的表达活动，语言，音乐，绘画，包括编程，无不是一种叙事活动，目的是让相同的人能感受到。爱情也是这样一种叙事的活动，我的叙事，是我过往的痕迹，和未来的一生，我们一起叙事，我们的爱情，就会只有我们连个人懂。人与动物最本质的区别也就是在这里了，人类有足够的脑容量去设计出复杂的系统。可是这里有两个陷阱，首先，为什么，在进化的初期，人类会把所有的营养放到这个看似累赘的大脑上？其次，如果人类的脑容量再大一点会怎样？人类的脑容量是有限的啊，也就意味着，我们设计出来的系统的复杂度是有限的，也就意味着，对于宇宙，我们是不可能全知的。那么这就很有意思了，宇宙中出现了一种生命，他能了解宇宙，但是却不能完全的了解，这种生命就会永远的的困死在这种半知的状态中，这种生命的终生都会为宇宙的本质苦恼，永远得不到真相。这样的生命是虚无的，是宇宙中的过程，就像是水波，当能量没了就什么都没了。人类竟然在这种虚无的过程中，设计出了这么多无聊的事，什么大喜大悲的情绪，什么功名财富，什么七情六欲，什么明器珍货。这些东西让无数的圣人,诗人，高高在上的人，卑微如草芥的人，沉迷其中，感受其中的乐趣与无趣，接受这样的一潭死水的一生。 我对这个世界充满困惑，而我活的太卑微。我在大保健的时候，很多的时候，想的太多。在宇宙中，做什么都不会有回应，在人间，没有人会想着我的想法，很开心遇到你，对错不重要，愿意倾听我，我就要认真的陪你走下去，去创造只有我们两个人的叙事。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>情书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%88%A9%E7%94%A8hexo%E4%B8%8Egithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[##博客搭建的流程 如果想要搭建属于自己的博客，而不是一些免费的博客的话，首先因该去购买自己的域名，服务器去管理自己的网站。这样做的缺点就是，要花费很多的时间去管理自己的网站，还要花钱购买服务器空间。 github提供了Pages功能，这样，利用github建立起来的博客，实际上是用户在github上建立一个仓库，然后github提供模板生成静态网页。有点像各大网站的个人主页编辑。github page可以与你域名关联。 在github上进行管理自己的博客，不单单是git commit这么简单，它需要一些静态站点生成器进行编辑渲染才能展示。这里我们用hexo 来生成html文件。在Hexo 的官方网站上，对它的定义是： Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 我的博客用的就是hexo+GitHub搭建起来的。流程如下： 建立github仓库 安装git,node.js,hexo等工具 申请自己的域名并跟github绑定 更换主题，美化博客 学习hexo可以个性化自己的博客框架。 这些教程网上都有很多，我引用一篇讲的好的： GitHub+Hexo 搭建个人网站详细教程 需要注意的是在安装hexo的时候会比较慢，需要翻墙。hexo安装初始化成功后，可以通过https://localhost:4000访问在本地查看。绑定自己的域名的时候分三步： 在阿里云上添加解析添加三条解析记录 在github上souce文件夹里添加CNAME文件，里面写上自己的域名。然后转到setting，在custom domain上写上自己的域名，如图：. 打开hexo的文件夹，在主文件夹里找到_config.yml 把自己的github.io的路径写到里面。 余下的工作就是换个主题，美化自己的博客了。我用的是next主题。hexo还有许多可以学习的地方，给自己的博客添加更多的东西，比如搜索，阅读统计之类的，我也在慢慢的学习中。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
